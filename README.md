# **Flutter Protobuf vs. JSON Performance Benchmark**

**Date:** August 29, 2025
**Target Hardware:** Texas Instruments AM62x SoC

---

## **1. Project Overview**

This project provides a benchmark comparing **Protocol Buffers (Protobuf)** against **JSON** for high-frequency data exchange.
The simulation mimics EV subsystem communication with packets sent every **50ms**.

Metrics measured:

* Data payload size
* Round-trip time (RTT)
* Serialization/deserialization speed
* Network throughput
* Latency jitter

---

## **2. Project Structure**

```text
/
├── protos/
│   └── ev_data.proto      # The single source of truth for data structures
│
├── lib/
│   ├── main.dart          # Main Flutter app: UI + TCP server + benchmark client
│   └── src/
│       └── generated/     # Auto-generated by protoc
│           ├── ev_data.pb.dart
│           ├── ev_data.pbenum.dart
│           └── ev_data.pbjson.dart
│
└── pubspec.yaml           # Project dependencies
```

* [`protos/ev_data.proto`](protos/ev_data.proto) → Protobuf definitions
* `lib/main.dart` → Flutter app (UI, TCP server, benchmark client, isolates)
* `lib/src/generated/` → Protoc-generated Dart classes

---

## **3. Setup and Execution Guide**

### **Prerequisites**

1. **Flutter SDK** installed.
2. **Protobuf Compiler (protoc)** installed and available in `PATH`.
3. **Dart protoc Plugin:**

```bash
dart pub global activate protoc_plugin
```

Ensure the Dart pub cache binary path is added to your system `PATH`:

* Windows:

  ```bash
  C:\Users\<YourUser>\AppData\Local\Pub\Cache\bin
  ```
* Linux/macOS:

  ```bash
  ~/.pub-cache/bin
  ```

---

### **Steps**

1. **Clone repo**

   ```bash
   git clone <repo-url>
   cd <project-root>
   ```

2. **Install dependencies**

   ```bash
   flutter pub get
   ```

3. **Generate Protobuf Dart files**

   ```bash
   protoc --dart_out=lib/src/generated -Iprotos protos/ev_data.proto
   ```

   This produces:

    * `ev_data.pb.dart`
    * `ev_data.pbenum.dart`
    * `ev_data.pbjson.dart`

4. **Run the app**

   ```bash
   flutter run
   ```

---

## **4. Benchmark Results and Analysis**

### **Test Platforms**

* **Windows 11 PC**: Intel Core i7 9th Gen (x86-64), 32GB RAM
* **TI AM62x EVM**: ARM Cortex-A53, 2GB RAM, Flutter-Pi

---

### **Initial Benchmark (Core Metrics)**

| Platform | Metric          |           JSON |   Protobuf | % Diff | Winner   |
| -------- | --------------- | -------------: | ---------: | -----: | -------- |
| Windows  | Avg. Size       |   995.11 bytes | **276.72** | -72.2% | Protobuf |
|          | Avg. RTT        |      603.82 µs | **531.50** | -12.0% | Protobuf |
|          | Serialization   |       59.19 µs |  **18.29** | -69.1% | Protobuf |
|          | Deserialization |       41.55 µs |  **15.71** | -62.2% | Protobuf |
| AM62x    | Avg. Size       |   994.98 bytes | **277.00** | -72.2% | Protobuf |
|          | Avg. RTT        | **1904.29 µs** | 1952.26 µs |  +2.5% | JSON     |
|          | Serialization   |      389.92 µs | **148.26** | -62.0% | Protobuf |
|          | Deserialization |      288.98 µs | **115.10** | -60.2% | Protobuf |

---

### **Final Benchmark (Extended Metrics)**

| Platform | Metric          |         JSON |      Protobuf | % Diff | Winner   |
| -------- | --------------- | -----------: | ------------: | -----: | -------- |
| Windows  | Avg. Size       | 995.16 bytes |    **276.84** | -72.2% | Protobuf |
|          | Avg. RTT        |    632.27 µs |    **596.41** |  -5.7% | Protobuf |
|          | RTT Jitter (σ)  |    909.58 µs |    **533.48** | -41.4% | Protobuf |
|          | Serialization   |     62.70 µs |     **19.89** | -68.3% | Protobuf |
|          | Deserialization |     45.86 µs |     **17.20** | -62.5% | Protobuf |
|          | Throughput      |   19.34 KB/s | **5.38 KB/s** | -72.2% | Protobuf |
| AM62x    | Avg. Size       | 995.29 bytes |    **276.74** | -72.2% | Protobuf |
|          | Avg. RTT        |   2482.61 µs |   **1799.80** | -27.5% | Protobuf |
|          | RTT Jitter (σ)  |    925.66 µs |    **593.24** | -35.9% | Protobuf |
|          | Serialization   |    354.17 µs |    **141.15** | -60.1% | Protobuf |
|          | Deserialization |    290.30 µs |    **105.85** | -63.5% | Protobuf |
|          | Throughput      |   19.34 KB/s | **5.38 KB/s** | -72.2% | Protobuf |

---

### **Key Insights**

1. **Data Size & Throughput**

    * Protobuf payloads are **\~72% smaller** → massive bandwidth + buffer savings.
    * Embedded devices benefit the most from this reduction.

2. **CPU Performance**

    * **Windows (x86):** Protobuf faster due to binary efficiency.
    * **AM62x (ARM):** Gap widens further → Protobuf uses **half the CPU time** vs. JSON.

3. **Latency & Jitter**

    * Protobuf improved RTT by **27.5%** on AM62x.
    * Jitter reduced by **36%**, making it more predictable → crucial for EV real-time control.

---

## **5. Conclusion**

On the **TI AM62x SoC**, **Protobuf is unequivocally superior** to JSON:

* **\~72% reduction in payload size**
* **>60% faster (serialization & deserialization)**
* **Lower RTT & jitter**
* **Much better CPU efficiency**

- JSON’s human readability does **not** justify its cost in embedded systems.
- **Recommendation:** Use **Protobuf** for EV subsystem communication on AM62x.

---
